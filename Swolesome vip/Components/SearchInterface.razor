@inject ApiService apiService
@inject SearchConfigService ConfigService
@using Swolesome_vip.Models
@using Swolesome_vip.Services

<div class="d-flex justify-content-between">
    <h4 class="text-lg font-semibold mb-2">Search</h4>
    <button class="btn btn-info"><i class="fa fa-gear"></i> Config</button>
</div>

<div class="mb-3">
    <label class="fw-semibold d-block mb-2">
        Input (one per line)
        @* This button triggers a file import when clicked, calling function TriggerFileImport *@
        @* <button type="button" class="btn btn-sm btn-outline-primary ms-2" *@
        @*         @onclick="TriggerFileImport"> *@
        @*     <i class="fa-solid fa-file-import me-1"></i> Import *@
        @* </button> *@
        <label class="btn btn-sm btn-outline-primary ms-2 btn-file">
            <i class="fa-solid fa-file-import me-1"></i> Import
            <InputFile OnChange="HandFileSelected" ref="fileInput" accept=".txt" class="d-none" />
        </label>
    </label>
    @* This textarea is two-way bound to the SearchInput variable. *@
    <textarea @bind="SearchInput" rows="5" class="form-control"></textarea>
</div>

<div class="mb-3">
    <div class="d-flex align-items-center gap-4 mt-2">
        @* This checkbox is two-way bound to the WildcardEnabled variable. You get the idea for the rest of the @bind attributes *@
        <label class="d-inline-flex align-items-center">
            <input type="checkbox" @bind="WildcardEnabled" class="mr-2"/>Wildcard
        </label>
        <label class="d-inline-flex align-items-center">
            <input type="checkbox" @bind="CaseSensitiveEnabled" class="mr-2"/>Case Sensitive
        </label>
    </div>
</div>

<div class="mb-3">
    <label class="form-label fw-medium mb-2">Input Types (select at least one)</label>
    <div class="d-flex gap-2 flex-wrap">
        @* Loop through all configured input types and create a checkbox for each *@
        @foreach (var type in ConfigService.Config.InputTypes)
        {
            <input type="checkbox" class="btn-check" id="btn-check-@type" autocomplete="off"
                   checked="@(SelectedInputTypes.Contains(type))"
                   @onchange="() => ToggleInputType(type)">
            <label class="btn btn-secondary btn-sm" for="btn-check-@type">@type</label>
        }
    </div>
</div>

<div class="mb-3">
    @if (isSearching)
    {
        <button class="btn btn-primary" disabled><i class="fa-solid fa-spinner fa-spin"></i> Searching...</button>   
    }
    else
    {
        <button class="btn btn-primary" @onclick="StartSearch"><i class="fa-solid fa-magnifying-glass"></i> Start Search</button>   
    }
</div>

@code {
    [Parameter] public EventCallback<List<SearchResult>> OnSearchCompleted { get; set; }
    private List<string> SelectedInputTypes { get; set; } = new();
    private string SearchInput { get; set; } = String.Empty;
    private bool WildcardEnabled { get; set; }
    private bool CaseSensitiveEnabled { get; set; }
    private List<SearchResult> results { get; set; } = new List<SearchResult>();

    private bool isSearching = false;
    private InputFile? fileInput;

    private async Task StartSearch()
    {
        results.Clear();
        if (string.IsNullOrWhiteSpace(SearchInput) || isSearching) return;
        isSearching = true;
        StateHasChanged(); // Force a re-render. This way the button is disabled while the search is running. 

        var searchInputList = SearchInput.Split(Environment.NewLine);

        foreach (var input in searchInputList)
        {
            var response = await apiService.SendRequestAsync(input, SelectedInputTypes, WildcardEnabled, CaseSensitiveEnabled);
            results.Add(new SearchResult
            {
                jsonData = response,
                Term = input,
                SelectedFields = SelectedInputTypes
            });
        }

        // InvokeAsync sends an callback to the parent component to update the UI
        await OnSearchCompleted.InvokeAsync(results);
        isSearching = false;
    }

    private async Task HandFileSelected(InputFileChangeEventArgs e)
    {
        var file = e.File;
        SearchInput = string.Empty;
        
        using var stream = file.OpenReadStream(maxAllowedSize: 1024 * 1024 * 10);
        using var reader = new StreamReader(stream);
        var content = await reader.ReadToEndAsync();
        
        var lines = content
            .Split(new[] {"\r", "\n"}, StringSplitOptions.RemoveEmptyEntries)
            .Select(x => x.Trim())
            .Where(x => !string.IsNullOrWhiteSpace(x))
            .ToList();
        
        SearchInput = string.Join(Environment.NewLine, lines);
    }
    
    private void ToggleInputType(string type)
    {
        if (SelectedInputTypes.Contains(type))
        {
            SelectedInputTypes.Remove(type);
        }
        else
        {
            SelectedInputTypes.Add(type);
        }
    }
}