@inject ApiService apiService
@inject SearchConfigService ConfigService
@using System.Text.Json
@using Swolesome_vip.Models
@using Swolesome_vip.Services

<div class="d-flex justify-content-between">
    <h4 class="text-lg font-semibold mb-2">Search</h4>
    <button class="btn btn-info"><i class="fa fa-gear"></i> Config</button>
</div>

<div class="mb-3">
    <label class="fw-semibold d-block mb-2">
        Input (one per line)
        @* This button triggers a file import when clicked, calling function TriggerFileImport *@
        @* <button type="button" class="btn btn-sm btn-outline-primary ms-2" *@
        @*         @onclick="TriggerFileImport"> *@
        @*     <i class="fa-solid fa-file-import me-1"></i> Import *@
        @* </button> *@
        <label class="btn btn-sm btn-outline-primary ms-2 btn-file">
            <i class="fa-solid fa-file-import me-1"></i> Import
            <InputFile OnChange="HandFileSelected" ref="fileInput" accept=".txt" class="d-none" />
        </label>
    </label>
    @* This textarea is two-way bound to the SearchInput variable. *@
    <textarea @bind="SearchInput" rows="5" class="form-control"></textarea>
</div>

<div class="mb-3">
    <div class="d-flex align-items-center gap-4 mt-2">
        @* This checkbox is two-way bound to the WildcardEnabled variable. You get the idea for the rest of the @bind attributes *@
        <label class="d-inline-flex align-items-center gap-1">
            <input type="checkbox" @bind="WildcardEnabled" class="mr-2"/>Wildcard
        </label>
        <label class="d-inline-flex align-items-center gap-1">
            <input type="checkbox" @bind="CaseSensitiveEnabled" class="mr-2"/>Case Sensitive
        </label>
    </div>
</div>

<div class="mb-3">
    <label class="form-label fw-medium mb-2">Input Types (select at least one)</label>
    <div class="d-flex gap-2 flex-wrap">
        @* Loop through all configured input types and create a checkbox for each *@
        @foreach (var type in ConfigService.Config.InputTypes)
        {
            <input type="checkbox" class="btn-check" id="btn-check-@type" autocomplete="off"
                   checked="@(SelectedInputTypes.Contains(type))"
                   @onchange="() => ToggleInputType(type)">
            <label class="btn btn-secondary btn-sm" for="btn-check-@type">@type</label>
        }
    </div>
</div>

<div class="mb-3">
    <label class="form-label fw-medium mb-2">Sources (optional)</label>

    <div class="dropdown @(sourcesDropdownOpen ? "show" : "")">
        <button class="btn btn-outline-secondary dropdown-toggle btn-sm"
                type="button"
                @onclick="ToggleSourcesDropdown"
                aria-expanded="@(sourcesDropdownOpen)">
            Select Sources (@SelectedSources.Count)
        </button>

        <div class="dropdown-menu p-2 @(sourcesDropdownOpen ? "show" : "")"
             style="max-height: 300px; overflow-y: auto;">
            @foreach (var source in ConfigService.Config.SourceTypes.OrderBy(s => s))
            {
                <div class="form-check">
                    <input class="form-check-input"
                           type="checkbox"
                           id="source-@source"
                           checked="@(SelectedSources.Contains(source))"
                           @onchange="() => ToggleSource(source)" />
                    <label class="form-check-label small" for="source-@source">@source</label>
                </div>
            }
        </div>
    </div>
</div>


<div class="mb-3">
    @if (isSearching)
    {
        <button class="btn btn-primary" disabled><i class="fa-solid fa-spinner fa-spin"></i> Searching...</button>   
    }
    else
    {
        <button class="btn btn-primary" @onclick="StartSearch"><i class="fa-solid fa-magnifying-glass"></i> Start Search</button>   
    }
</div>

@code {
    [Parameter] public EventCallback<List<SearchResult>> OnSearchCompleted { get; set; }

    private List<string> SelectedSources { get; set; } = new();
    private List<string> SelectedInputTypes { get; set; } = new List<string>
    {
        "username", "email"
    };
    private string SearchInput { get; set; } = String.Empty;
    private bool WildcardEnabled { get; set; }
    private bool CaseSensitiveEnabled { get; set; }
    private List<SearchResult> results { get; set; } = new List<SearchResult>();

    private bool sourcesDropdownOpen = false;
    private bool isSearching = false;
    private InputFile? fileInput;

    private async Task StartSearch()
    {
        results.Clear();
        if (string.IsNullOrWhiteSpace(SearchInput) || isSearching)
            return;

        isSearching = true;
        StateHasChanged();

        var searchInputList = SearchInput
            .Split(Environment.NewLine, StringSplitOptions.RemoveEmptyEntries);
        var loweredSources = SelectedSources
            .Select(s => s.ToLowerInvariant())
            .ToList();

        foreach (var input in searchInputList)
        {
            var response = await apiService.SendRequestAsync(input, SelectedInputTypes, WildcardEnabled, CaseSensitiveEnabled);
            if (response.RootElement.TryGetProperty("error", out var errorProp) ||
                !response.RootElement.TryGetProperty("results", out var resultsArray))
            {
                // Wrap the response in a list if it contains an error, otherwise empty list
                var jsonData = errorProp.ValueKind != JsonValueKind.Undefined
                    ? new List<JsonElement> { response.RootElement }
                    : new List<JsonElement>();

                results.Add(new SearchResult
                {
                    JsonData = jsonData,
                    Term = input,
                    SelectedFields = new List<string>(SelectedInputTypes)
                });

                continue;
            }

            var jsonResults = resultsArray.EnumerateArray();

            IEnumerable<JsonElement> filteredResults = jsonResults;

            if (loweredSources.Count > 0)
            {
                filteredResults = jsonResults.Where(r =>
                {
                    if (!r.TryGetProperty("source", out var srcProp))
                        return false;

                    var src = srcProp.GetString();
                    if (string.IsNullOrEmpty(src))
                        return false;

                    var srcLower = src.ToLowerInvariant();
                    return loweredSources.Any(sel => srcLower.Contains(sel));
                });
            }

            results.Add(new SearchResult
            {
                JsonData = filteredResults.ToList(),
                Term = input,
                SelectedFields = new List<string>(SelectedInputTypes)
            });
        }

        await OnSearchCompleted.InvokeAsync(results);
        isSearching = false;
    }

    private async Task HandFileSelected(InputFileChangeEventArgs e)
    {
        var file = e.File;
        SearchInput = string.Empty;
        
        using var stream = file.OpenReadStream(maxAllowedSize: 1024 * 1024 * 10);
        using var reader = new StreamReader(stream);
        var content = await reader.ReadToEndAsync();
        
        var lines = content
            .Split(new[] {"\r", "\n"}, StringSplitOptions.RemoveEmptyEntries)
            .Select(x => x.Trim())
            .Where(x => !string.IsNullOrWhiteSpace(x))
            .ToList();
        
        SearchInput = string.Join(Environment.NewLine, lines);
    }
    
    private void ToggleSourcesDropdown()
    {
        sourcesDropdownOpen = !sourcesDropdownOpen;
    }
    
    private void ToggleInputType(string type)
    {
        if (SelectedInputTypes.Contains(type))
        {
            SelectedInputTypes.Remove(type);
        }
        else
        {
            SelectedInputTypes.Add(type);
        }
    }
    
    private void ToggleSource(string source)
    {
        if (SelectedSources.Contains(source))
            SelectedSources.Remove(source);
        else
            SelectedSources.Add(source);
    }
}